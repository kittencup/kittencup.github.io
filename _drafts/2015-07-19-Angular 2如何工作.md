---
layout: post
title: "Angular 2如何工作"
date: 2015-07-19
categories: javascript
---

(Angular 如何工作)How Angular Works
------

在本章，我们将讨论Angular 2中得高级概念，我们的想法是，通过采取退后一步，我们可以看到所有的组件如何相互配合。

如果你有使用过Angular 1,您会注意到Angular 2以一个新的思维模式来构建应用程序。别慌!对于Angular 1用户来讲Angular 2既简单和熟悉。在下一章,我们将专门讨论如何转换应用程序从Angular 1到Angular 2

在后面的章节中,我们将深入了解每个概念,但在这里我们只是要给概述和解释的基本思想。

第一个大的思想是一个Angular 2应用程序由组件构成。组件的一种方式是教浏览器来认识新标签，如果你有Angular 1的使用背景,组件是类似于Angular 1指令(事实证明,Angular 2也有指令,但是以后我们会进一步讨论这个区别)。

然而 Angular 2组件相对于Angular 1指令有一些显著的优势。我们将在下面讨论。首先，让我们从头开始：应用(application)。

(应用)Application
------

Angular 2应用程序只不过是一个是组件树。

在树的根部，最顶层的组件就是应用的本身，这就是浏览器将引导的(boostrap)的应用

其中一个有关组件的大事是，他们是可组合。这意味着，我们可以从较小组件来建立更大的组件。应用程序只是一个简单的渲染其他组件的组件。

因为组件是一个父/子树的结构,每个组件呈现时,递归地呈现其子组件。

例如,让我们来讨论一个虚构的库存管理应用程序，下面是它的页面模型:

![](/images/2015-07-19-Angular 2如何工作/a.png)

鉴于这种模型,编写这个应用程序我们要做的第一件事就是把它分成单个组件(组织成一个树)。在这个例子中,我们可以组页面分成三个相同级别的组件

* 导航组件
* 面包屑组件
* 产品列表组件

导航组件 该组件将渲染导航部分。这将允许用户访问应用程序的其他页面

![](/images/2015-07-19-Angular 2如何工作/b.png)

面包屑组件 这将渲染表示应用程序中的用户目前在哪里。

![](/images/2015-07-19-Angular 2如何工作/c.png)

产品列表组件 这将是一个表示产品的集合。

![](/images/2015-07-19-Angular 2如何工作/d.png)

把这个组件分解成更小的下一个级别组件,我们可以说,产品列表组件是有多个产品列组成的

![](/images/2015-07-19-Angular 2如何工作/e.png)

当然,我们可以继续更进一步,将每个产品行分解成更小的片段:

* 产品图片(Product Image)组件，这将是负责渲染产品图片，获取图片名字(例如,组件知道如何使用适当的Amazon S3的URL来获取图像）
* 产品分类(Product Department)组件，给定一个产品分类id，来渲染分类树，类似于 Men > Shoes > Running Shoes
* 显示价格(Price Display)将是一个更通用的组件,跨越应用程序时,可以再次利用,是用来正确呈现一个价格。想象我们的实现定制的定价如果用户已经登录了则包括折扣或运费等。在这个组件我们可以实现所有这些行为。
                       
最后，把它全部连成一个树表示，我们最终得到如下图：
  
![](/images/2015-07-19-Angular 2如何工作/f.png)

在顶部，我们看到库存管理app：这是我们的应用程序(用来bootstrap)。

根据应用程序，我们有导航，面包屑和产品列表的组件。需要注意的重要一点是，每个应用程序只能有一个顶级组件。

组件(Components)
------

正如你所看到的，组件是Angular 2应用基本构建块。我们把应用程序划分为更细粒度的子组件。

我们将使用他们,所以值得更仔细地看着他们。每个组件都是由三部分组成:

* 组件 装饰者(Decorator)
* 视图
* 控制器

![](/images/2015-07-19-Angular 2如何工作/g.png)

该产品列表组件的实现可能是：

```javascript
// 组件 装饰者(Decorator)
@Component({
  selector: 'products-list',
  properties: ['products']
})
// 视图注释(Annotation)
@View({
  directives: [ProductRow, NgFor], 
  template: `
    <div class="products-list">
      <div product-row *ng-for="#product in products" [product]="product"> </div>
    </div>
  `
})
// 控制器
class ProductsList { 
  products: Array<Product>;
}
```

如果你一直使用Angular 1的语法则看起来很奇怪!但思想很相似,所以让我们一步一步来看他们:

组件装饰和视图定义部分为注释,但是控制器是一个由一个类来表示。

如果你不知道注释(Annotations),可以通过这篇文章[https://github.com/Microsoft/TypeScript/issues/1557](https://github.com/Microsoft/TypeScript/issues/1557)来了解

现在让我们来看看每个部分详细内容。

组件装饰者(Component Decorator)
------

组件装饰者是你声明在组件外部如何将你的组件进行交互。

有许多可用的选项配置组件,我们将在组件这章组件详细了解。这里我们涉及的一些基础知识。


#### 组件选择器(Component selector)

选择器(selector)键值,表明你的组件将渲染的HTML标签。这个想法是类似于CSS或XPath选择器。选择器将HTML元素将匹配该组件。
在这种情况下, `selector:'products-list'`, 在我们的HTML，我们要匹配products-list标签，也就是说每当我们使用它,那么一个新的标签就被定义了新的内置功能，例如,当我们使用这个HTML时

```html
<products-list></products-list>
```

Angular 将使用ProductsList组件来实现功能。

另外,有了这个选择器,我们也可以使用常规的div,指定的组件将作为一个属性:

```html
<div products-list></div>
```

#### 组件属性(Component Properties)

@Component注释还有另一个键:properties,通过properties键可配置组件期望接受的参数，这里的想法是，在组件将被渲染时接收一个数组形式的product。

properties键中声明的所有参数表示你的组件期望从其他组件中获取这些内容

properties需要一个字符串类型的数组，它指定了该组件所需要接受的输入参数，这些字符串可以简单的为每个属性的名字或者有格式的‘componentProperty:exposedProperty’

例如，我们可以又一个组件看起来像这样：

```javascript
@Component({
  //...
  properties: ['name', 'age', 'enabled']
  //...
})
class MyComponent {
  name: string;
  age: number;
  enabled: boolean;
}
```

但是，如果我想在组件中使用isEnabled属性来代表properties暴露的enabled属性，我可以使用另一种格式

```javascript
@Component({
  //...
  properties: [
    'name:name',
    'age:age',
    'isEnabled:enabled'
  ]
  //...
})
class MyComponent {
  name: string;
  age: number;
  isEnabled: boolean;
}
```

在进一步，只需要启动一个明确的映射，enabled -> isEnabled,我们甚至可以简化成这样写：

```javascript
@Component({
  //...
  properties: [
    'name',
    'age',
    'isEnabled:enabled'
  ]
  //...
})
class MyComponent {
  name: string;
  age: number;
  isEnabled: boolean;
}
```

在properties数组中，当作key及value都有一个特定的意义:

* 当作key (name,age,isEnabled),代表在控制器中绑定的属性名
* 当作value (name,age,enabled),代表组件如何获取其他组件提供内容的属性名

在这种情况下，name和age可以使用简单的字符串，然而对于enabled属性我们选择不同的值，enabled在view中会表示是否启用的状态，所以在控制器种我们将他转换成isEnabled属性。我们很快就会看到更多这样的例子。

我们现在开始学习，如果在组件的视图部分使用暴露在外的属性

控制器(Controller)
------

组件的控制器是一个类，该类包含了所有的组件属性，包含了组件应该执行的行为

```javascript
class ProductsList {
   products: Array<Product>;
}
```

在这里，我们指定一个产品实例类型的数组变量，但是在这个例子种我们没有定义任何行为(不就将会有)

视图(View)
------

你可以把view看作为组件的可视化的部分，它通过@View注解表示并且他声明这个组件具有HTML模板

```javascript
// The view annotation
@View({
  directives: [ProductRow, NgFor],
  template: `
    <div class="products-list">
    <div product-row *ng-for="#product in products" [product]="product">
      </div>
    </div>
  `
})
```

这个@View 注解又许多可以配置的选项，但在这里我们只使用了2个:

* directives:指定我们希望在此视图种使用的其他组件，此选项采用类(class)类型的数组结构，不像Angular 1,所有的指令都是全局的，在Angular 2种，你必须说明打算使用哪些指令，在这里我们要使用ProductRow指令
* template:我们的组件在这里要渲染的HTML模板，请注意，我们在这里使用了反引号，在typescript中是多行字符串语法，在html模板中你可能注意到了很多语法，让我们一起去详细介绍每一部分。

属性和事件(Properties and Events)
------

还有两个主要概念:我们需要意识到使用组件的属性绑定和事件绑定。

数据通过组件上的属性绑定流入组件，数据通过组件上的事件绑定流出组件

在你的组件中把属性绑定+事件绑定设定成公开(Public)的Api

对于"读(reading)"数据 数据在你的组件中可以通过使用属性(properties)绑定到视图(view)。

对于"写(writing)"数据 你的应用不会是只读的，用户也需要输入数据，使用事件处理用户输入。

例如，如果我们想要添加一个按钮或表单提交的行为，我们需在视图(view)中声明，也就是说我们在视图种添加事件绑定，然而，处理该事件的实际执行发生在控制器。

在谈到属性(properties),组件装饰者(decorator)知道什么属性被定义和什么视图(view)需要被渲染，当谈到事件(events),这是相反的，视图知道什么事件被触发，控制器则知道如何处理事件

数据绑定(Data binding)
------

让我们来看看view(视图)如何来使用通过属性绑定到组件的数据，我们认为有2种方法就可以使用属性

#### 私有属性(Private Properties)

第一种方式是内联表达式(inline expression)，例如

```javascript
@View({
 template: `
  The next number is {% raw %}{{ number + 1 }}{% endraw %}
 `
})
class SomeComponent {
 number: number;

 constructor() {
   this.number = 2;
 }
}
```
在这里我们在表达式中使用控制器中声明的number变量，在渲染组件时，表达式会被替换，将渲染成数字3

使用{% raw %}{{...}}{% endraw %}语法被称为模板绑定，它告诉view(视图)在我们模板中的这个位置我们想使用括号内表达式的值

在先前的例子中，属性number是控制器独有的(controller-only)，你也可以把他当作该组件私有属性，私有属性只有在组件内部才是可见的，它们通常仅在内部使用。

#### 公开属性(Public Properties)

第二种方法使用一个表达式是通过使用一个组件属性。

与控制器独有属性对比，另一种类型的属性是一个组件的属性，组件属性声明在组件装饰者上(decorator),因此在组件外也是可见的。你可以理论上认为是“公共”属性。

```javascript
“@Component({
  selector: 'some-component',
  properties: ['number']
})
@View({
   template: `
     The next number is {% raw %}{{ number + 1 }}{% endraw %}
   `
})
class SomeComponent {
  number: number;
}
```

在这个例子中，我们暴露出公共属性number，我们允许从外部组件来传递。

但现在，我们已经暴露了这个属性，我们如何实际使用它？

当使用组件时，使用[property]="expression"符号来绑定值。

所以我们可以这样做

```html
<some-component [number]='41'>
```

我们组件将会呈现数字42

不管我们使用内置组件还是自定义组件，在上面设置属性的语法是一样的

例如，我想在我的视图上为input标签设定一个number的值，我们可以使用相同的属性设定表示法

```javascript
@View({
  template: `
    <input [value]='number + 1'>
  `
})
class SomeComponent {
  number: number;

  constructor() {
   this.number = 2;
 }
}
```

事件绑定(Event binding)
-----

在上一节，我们讲了如何通过属性绑定让数据流入组件，在这一节，让我们来看看如果使用事件让数据流出组件。

当你想要从你组件内像外部发送数据时，你可以使用事件绑定，比如说有一个组件有一个按钮，我们在点击按钮时需要做点什么。

做这件事的方法是通过将该按钮的单机事件绑定到我们组件的控制器上的一个方法。你可以使用(event)="action"表示法

下面有一个例子，在这里我们根据按钮有一个计数器递增(或递减)

```javascript
@Component({
  ...
})
@View({
  template: `
    {{ value }}
    <button (click)="increase()">Increase</button>
    <button (click)="decrease()">Decrease</button>
  `
})
class Counter {
 value: number;

 constructor() {
   this.value = 1;
 }

 increase() {
   this.value++;
 }
 decrease() {
   this.value--;
 }
}
```

在这个例子种，我们说每点击第一个按钮时，我们要调用我们控制器上的increase()方法，二对于第二个按钮的点击，我们要调用decrease()方法。

括号属性语法如下:(event)="action",在这里我们在这个按钮上监听的是click事件，还有许多其他事件可以监听，如,mousedown,mousemove,dbl-click等

在本实例种，该事件是组件内部的，在创建特有的组件时，我们也可以暴露"公开(public)"的事件，允许组件与外部对话，我们将在下一个例子中做到这个

把这些连起来(Putting it all together)
-------

让我们来修改使用前面的例子，当我们点击一个给定行，让我们的productsList组件知道，我们可以用这个事件来重定向到一个单独的产品页面

为了做到这一点，让我们先处理productslist组件和productrow组件之间的互动

```javascript
@Component({
    selector: 'product-row',
    properties: ['product'],
    events: ['click']
})
@View({
    template: `
        <div class="product-row" (click)="clicked()">
            <div product-image [product]="product"></div>
            <div product-department [department]="product.department_id"></div>
            <div price-display [price]="product.price">
            </div>
        </div>
    `,
    directives: [ProductImage, ProductDepartment, PriceDisplay]
})
class ProductRow {
  product: Product;
  click: EventEmitter;
  constructor() {
    this.click = new EventEmitter();
  }
  clicked() {
    this.click.next(this.product);
  }
}
```

productRow看起来有些新东西，请注意，在组件装饰者(decorator)上我们有一个新的events属性，这表示你的组件将触发你声明的自定义事件


