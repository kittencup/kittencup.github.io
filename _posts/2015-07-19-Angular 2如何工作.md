---
layout: post
title: "Angular 2如何工作"
date: 2015-07-19
categories: javascript
---

Angular 如何工作
------

在本章，我们将讨论Angular 2中得高级概念，我们的想法是，通过一步一步的方式，我们可以看到所有的组件是如何组合在一起。

如果你有使用过Angular 1,您会注意到Angular 2以一个新的思维模式来构建应用程序。别慌!对于Angular 1用户来讲Angular 2既简单又熟悉。在下一章,我们将专门讨论如何从Angular 1转换应用到Angular 2

在后面的章节中,我们将深入了解每个概念,但在这里我们只是要给概述和解释的基本思想。

第一个大的思想是一个Angular 2应用是由组件(Component)构成。组件的一种方式是教浏览器来认识新标签，如果你有Angular 1的使用背景,组件是类似于Angular 1指令(事实证明,Angular 2也有指令,但是以后我们会进一步讨论这个区别)。

然而 Angular 2组件相对于Angular 1指令有一些显著的优势。我们将在下面讨论。首先，让我们从头开始：应用(application)。

应用
------

Angular 2应用程序只不过是一个是组件树。

在树的根部，最顶层的组件就是应用的本身，这就是浏览器将引导的(bootstrapping)的应用

其中一个有关组件的大事是，他们是可组合。这意味着，我们可以从较小组件来建立更大的组件。应用只是一个简单的渲染其他组件的组件。

因为组件是一个父/子树的结构,每个组件呈现时,将递归地呈现其子组件。

例如,让我们来讨论一个虚构的库存管理应用程序，下面是它的页面模型:

![](/images/2015-07-19-Angular 2如何工作/a.png)

鉴于这种模型,编写这个应用程序我们要做的第一件事就是把它分成单个组件(组织成一个树)。在这个例子中,我们可以组页面分成三个相同级别的组件

* 导航组件
* 面包屑组件
* 产品列表组件

导航组件 该组件将渲染导航部分。这将允许用户访问应用的其他页面

![](/images/2015-07-19-Angular 2如何工作/b.png)

面包屑组件 这将渲染表示应用程序中的用户目前在哪里。

![](/images/2015-07-19-Angular 2如何工作/c.png)

产品列表组件 这将是一个表示产品的集合。

![](/images/2015-07-19-Angular 2如何工作/d.png)

把这个组件分解成更小的下一个级别组件,我们可以说,产品列表组件是有多个产品列组成的

![](/images/2015-07-19-Angular 2如何工作/e.png)

当然,我们可以继续更进一步,将每个产品行分解成更小的片段:

* 产品图片(Product Image)组件，这将是负责渲染产品图片，获取图片名字(例如,组件知道如何使用适当的Amazon S3的URL来获取图像）
* 产品分类(Product Department)组件，给定一个产品分类id，来渲染分类树，类似于 Men > Shoes > Running Shoes
* 显示价格(Price Display)将是一个更通用的组件,跨越应用时,可以再次利用,是用来正确呈现一个价格。想象我们的实现定制的定价如果用户已经登录了则包括折扣或运费等。在这个组件我们可以实现所有这些行为。
                       
最后，把它全部连成一个树表示，我们最终得到如下图：
  
![](/images/2015-07-19-Angular 2如何工作/f.png)

在顶部，我们看到库存管理app：这是我们的应用

根据应用，我们有导航，面包屑和产品列表的组件。需要注意的重要一点是，每个应用只能有一个顶层组件。

组件
------

正如你所看到的，组件是Angular 2应用基本构建块。我们把应用程序划分为更细粒度的子组件。

我们将使用它们,所以值得更仔细地看着它们。每个组件都是由三部分组成:

* 组件[Decorator](https://github.com/wycats/javascript-decorators)
* 视图
* 控制器

![](/images/2015-07-19-Angular 2如何工作/g.png)

该产品列表组件的实现可能是：

```javascript
// 组件 Decorator
@Component({
  selector: 'products-list',
  properties: ['products']
})
// 视图注解(Annotation)
@View({
  directives: [ProductRow, NgFor], 
  template: `
    <div class="products-list">
      <div product-row *ng-for="#product in products" [product]="product"> </div>
    </div>
  `
})
// 控制器
class ProductsList { 
  products: Array<Product>;
}
```

如果你一直使用Angular 1的语法则看起来很奇怪!但思想很相似,所以让我们一步一步来看他们:

组件Decorator和视图定义部分为注解,但是控制器是一个由一个类来表示。

如果你不知道注解(Annotations),可以通过这篇文章[https://github.com/Microsoft/TypeScript/issues/1557](https://github.com/Microsoft/TypeScript/issues/1557)来了解

现在让我们来看看每个部分详细内容。

组件Decorator
------

组件Decorator是你声明在组件外部如何和你的组件进行交互。

有许多可用的选项配置组件,我们将在组件这章详细了解。这里我们先涉及一些基础知识。

#### 组件选择器(Selector)

选择器,表明你的组件将渲染的HTML标签。这个想法是类似于CSS或XPath选择器。选择器将HTML元素匹配该组件。
在这种情况下, `selector:'products-list'`, 是要匹配products-list标签，也就是说每当我们使用它,那么这个新的标签就被定义了新的内置功能，例如,当我们HTML为

```html
<products-list></products-list>
```

Angular 将使用ProductsList组件来实现这功能。

另外,我们也可以使用常规的div,指定的组件将作为一个属性:

```html
<div products-list></div>
```

#### 组件属性(Properties)

`@Component`注解还有另一个键:properties,通过properties键可配置组件期望接受的参数，这里的想法是，在组件将被渲染时接收一个数组形式的product。

properties键中声明的所有参数表示你的组件期望从标签中获取的属性

properties需要一个字符串类型的数组，它指定了该组件所需要接受的输入参数，这些字符串可以简单的使用每个属性的名字或者有格式的‘componentProperty:exposedProperty’

例如，我们可以有一个组件看起来像这样：

```javascript
@Component({
  //...
  properties: ['name', 'age', 'enabled']
  //...
})
class MyComponent {
  name: string;
  age: number;
  enabled: boolean;
}
```

但是，如果我想在组件中使用isEnabled属性名来代替properties中标签暴露的enabled属性名，我可以使用另一种格式

```javascript
@Component({
  //...
  properties: [
    'name:name',
    'age:age',
    'isEnabled:enabled'
  ]
  //...
})
class MyComponent {
  name: string;
  age: number;
  isEnabled: boolean;
}
```

在进一步，只需要启动一个明确的映射，enabled -> isEnabled,我们甚至可以简化成这样写：

```javascript
@Component({
  //...
  properties: [
    'name',
    'age',
    'isEnabled:enabled'
  ]
  //...
})
class MyComponent {
  name: string;
  age: number;
  isEnabled: boolean;
}
```

在properties数组中，key:value字符串都有一个特定的意义:

* 当作key (name,age,isEnabled),代表在控制器中绑定的属性名
* 当作value (name,age,enabled),代表组件如何从标签中的属性名

在这种情况下，name和age可以使用简单的字符串，然而对于enabled属性我们选择不同的值，enabled在view中会表示是否启用的状态，为了更好的表达属性的意思，所以在控制器种我们将他转换成isEnabled属性。我们很快就会看到更多这样的例子。

我们现在开始学习，如果视图部分使用组件暴露在外的属性

控制器
------

组件的控制器是一个类，该类包含了所有的组件属性，包含了组件应该执行的行为

```javascript
class ProductsList {
   products: Array<Product>;
}
```

在这里，我们指定一个产品实例类型的数组变量，但是在这个例子种我们没有定义任何行为(不久将会有)

视图
------

你可以把view看作为组件的可视化的部分，它通过`@View`注解声明这个组件具有HTML模板

```javascript
// The view annotation
@View({
  directives: [ProductRow, NgFor],
  template: `
    <div class="products-list">
    <div product-row *ng-for="#product in products" [product]="product">
      </div>
    </div>
  `
})
```

这个`@View` 注解有许多可以配置的选项，但在这里我们只使用了2个:

* directives:指定我们希望在此视图种使用的其他组件，此选项采用类(class)类型的数组结构，不像Angular 1,所有的指令都是全局的，在Angular 2中，你必须说明打算使用哪些指令，在这里我们要使用ProductRow指令
* template:我们的组件在这里要渲染的HTML模板，请注意，我们在这里使用了反引号，是typescript中多行字符串语法，在html模板中你可能注意到了很多语法，让我们一起去详细介绍每一部分。

属性和事件
------

还有两个主要概念:我们需要使用组件的属性绑定和事件绑定。

数据通过组件标签上的属性绑定流入组件，数据通过组件上的事件绑定流出组件

请将属性绑定+事件绑定定义为组件的公共接口。

对于"读"数据 数据在你的组件中可以通过使用属性绑定提供给视图

对于"写"数据 你的应用不会是只读的，用户也需要输入数据，使用事件处理用户输入。

例如，如果我们想要添加一个按钮或表单提交的行为，我们需在视图中声明，也就是说我们在视图种添加事件绑定，然而，处理该事件的实际执行发生在控制器。

在谈到属性，组件decorator知道什么属性被定义和什么视图需要被渲染，当谈到事件,这是相反的，视图知道什么事件被触发，控制器则知道如何处理事件

数据绑定
------

让我们来看看如何在视图使用绑定到组件的属性，有2种方法可以使用属性

#### 私有属性

第一种方式是内联表达式(inline expression)，例如

```javascript
@View({
 template: `
  The next number is {% raw %}{{ number + 1 }}{% endraw %}
 `
})
class SomeComponent {
 number: number;
 constructor() {
   this.number = 2;
 }
}
```

在这里我们在表达式中使用控制器中声明的number变量，在渲染组件时，表达式会被替换，将渲染成数字3

使用{% raw %}{{...}}{% endraw %}语法被称为模板绑定，它告诉视图在我们模板中的这个位置我们想使用括号内表达式的值

在这个例子中，属性number是控制器独有的，你也可以把他当作该组件私有属性，私有属性只有在组件内部才是可见的，它们通常仅在内部使用。

#### 公开属性

第二种方法使用一个表达式是通过使用一个组件属性。

与控制器独有属性对比，另一种类型的属性是一个组件的属性，组件属性声明在组件decorator上,因此在组件外也是可见的。你可以理论上认为是“公共”属性。

```javascript
“@Component({
  selector: 'some-component',
  properties: ['number']
})
@View({
   template: `
     The next number is {% raw %}{{ number + 1 }}{% endraw %}
   `
})
class SomeComponent {
  number: number;
}
```

在这个例子中，我们暴露出公共属性number，我们允许从外部来传递。

我们已经暴露了这个属性，但我们如何实际使用它？

当使用组件时，使用[property]="expression"符号来绑定值。

所以我们可以这样做

```html
<some-component [number]='41'>
```

我们组件将会呈现数字42

不管我们使用内置组件还是自定义组件，在上面设置属性的语法是一样的

例如，我想在我的视图上为input标签设定一个value为number+1,我们可以使用相同的属性设定表示法

```javascript
@View({
  template:`
    <input [value]='number + 1'>
  `
})
class SomeComponent {
  number: number;
  constructor() {
   this.number = 2;
 }
}
```

事件绑定
-----

在上一节，我们讲了如何通过属性绑定让数据流入组件，在这一节，让我们来看看如果使用事件让数据流出组件。

当你想要从你组件内像外部发送数据时，你可以使用事件绑定，比如说有一个组件有一个按钮，我们在点击按钮时需要做点什么。

做这件事的方法是通过将该按钮的点击事件绑定到我们组件的控制器上的一个方法。你可以使用(event)="action"表示法

下面有一个例子，在这里我们根据按钮有一个计数器递增(或递减)

```javascript
@Component({
  ...
})
@View({
  template: `
    {% raw %}{{ value }}{% endraw %}
    <button (click)="increase()">Increase</button>
    <button (click)="decrease()">Decrease</button>
  `
})
class Counter {
 value: number;
 constructor() {
   this.value = 1;
 }
 increase() {
   this.value++;
 }
 decrease() {
   this.value--;
 }
}
```

在这个例子种，我们说每点击第一个按钮时，我们要调用我们控制器上的increase()方法，对于第二个按钮的点击，我们要调用decrease()方法。

括号属性语法如下:(event)="action",在这里我们在这个按钮上监听的是click事件，还有许多其他事件可以监听，如,mousedown,mousemove,dbl-click等

在本实例中，该事件是组件内部的，在创建特有的组件时，我们也可以暴露"公开"的事件，允许组件与外部对话，我们将在下一个例子中做到这个

把这些内容连起来
-------

让我们来修改使用前面的例子，当我们点击一个给定行，让我们的productsList组件知道，我们可以用这个事件来重定向到一个单独的产品页面

为了做到这一点，让我们先处理productslist组件和productrow组件之间的互动

```javascript
@Component({
    selector: 'product-row',
    properties: ['product'],
    events: ['click']
})
@View({
    template: `
        <div class="product-row" (click)="clicked()">
            <div product-image [product]="product"></div>
            <div product-department [department]="product.department_id"></div>
            <div price-display [price]="product.price">
            </div>
        </div>
    `,
    directives: [ProductImage, ProductDepartment, PriceDisplay]
})
class ProductRow {
  product: Product;
  click: EventEmitter;
  constructor() {
    this.click = new EventEmitter();
  }
  clicked() {
    this.click.next(this.product);
  }
}
```

productRow看起来有些新东西，请注意，在组件decorator上我们有一个新的events属性，表示允许发射自定义事件列表

我们也可以在@view内给product-row绑定点击事件，使用(click)="clicked()"

当div被点击时，Angular 2会去调用控制器内的clicked()方法

EventEmitter正如名字所示,我们的组件想要像外部发射一个事件时，我们可以使用这个EventEmitter类

所以我们查看控制器内的的clicked方法

```javascript
clicked() {
  this.click.next(this.product);
}
```

你可以看到在EventEmitter中我们调用next方法，并传递这个ProductRow所持有的product数据，我们所做的是将事件转发给正在监听的任何组件，这样，如果我们有另一个组件需要监听该事件，我们可以这样写：

```html
<div product-row [product]="product" (click)="display(product)">
</div>
```

然后，这个组件控制器的display()方法会被调用时，product将传递给这个方法。

数据流
------

所以我们可以说,数据流从ProductsList上设置的product属性流入我们的ProductRow组件

![](/images/2015-07-19-Angular 2如何工作/h.png)
 
每一个ProductRow点击事件发射到ProductsList组件上，使数据从ProductRow组件流出流入ProductsList 如下图所示

![](/images/2015-07-19-Angular 2如何工作/i.png)

重要的是要知道，数据绑定是单向的：从父组件到子组件。这种绑定是自动的，并且只有一个方向。这不同于Angular 1，数据绑定是双向的。它使我们的程序更加容易推理。我们将在关于如何管理数据的章节进一步讨论更多。

摘要
-----

在本章中，我们了解到，Angular 2的核心概念是组件。任何Angular 2的应用程序是一个组成部分，由其它更小，更多的颗粒组成。

组件是由三部分组成，组件Decorator，一个视图 和一个控制器。组件Decorator描述组件的配置选项。在视图中，我们将描述组件将如何呈现，以及如何在渲染时使用其他组件。最后，在控制器上创建组件的行为，或者组件的业务逻辑。

在Angular 2所有的绑定只有一种方向。这是一个很大的区别，在Angular 1，所有的绑定是双向的。

为此，组件应该通过属性接收数据，通过使用事件发送数据。这样，其他组件可以绑定这些事件来响应它们。

现在，我们学习了Angular 2如果工作，让我们开始更详细地了解组件。
